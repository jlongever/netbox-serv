# coding: utf-8

"""
    

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ApidcimApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def console_port_delete(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_delete(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_port_delete_with_http_info(pk, **kwargs)
        else:
            (data) = self.console_port_delete_with_http_info(pk, **kwargs)
            return data

    def console_port_delete_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_delete_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_port_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_port_delete`")

        resource_path = '/api/dcim/console-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsolePortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def console_port_get(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_port_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.console_port_get_with_http_info(pk, **kwargs)
            return data

    def console_port_get_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_port_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_port_get`")

        resource_path = '/api/dcim/console-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsolePortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def console_port_list_get(self, pk, **kwargs):
        """
        List console ports (by device)
        <p>List console ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_port_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.console_port_list_get_with_http_info(pk, **kwargs)
            return data

    def console_port_list_get_with_http_info(self, pk, **kwargs):
        """
        List console ports (by device)
        <p>List console ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_port_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_port_list_get`")

        resource_path = '/api/dcim/devices/{pk}/console-ports/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsolePortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def console_port_patch(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_patch(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device: 
        :param str name: 
        :param str cs_port: 
        :param bool connection_status: 
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_port_patch_with_http_info(pk, **kwargs)
        else:
            (data) = self.console_port_patch_with_http_info(pk, **kwargs)
            return data

    def console_port_patch_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_patch_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device: 
        :param str name: 
        :param str cs_port: 
        :param bool connection_status: 
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'device', 'name', 'cs_port', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_port_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_port_patch`")

        resource_path = '/api/dcim/console-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'device' in params:
            form_params.append(('device', params['device']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'cs_port' in params:
            form_params.append(('cs_port', params['cs_port']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsolePortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def console_port_put(self, pk, device, name, cs_port, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_put(pk, device, name, cs_port, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device:  (required)
        :param str name:  (required)
        :param str cs_port:  (required)
        :param bool connection_status: 
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_port_put_with_http_info(pk, device, name, cs_port, **kwargs)
        else:
            (data) = self.console_port_put_with_http_info(pk, device, name, cs_port, **kwargs)
            return data

    def console_port_put_with_http_info(self, pk, device, name, cs_port, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_port_put_with_http_info(pk, device, name, cs_port, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device:  (required)
        :param str name:  (required)
        :param str cs_port:  (required)
        :param bool connection_status: 
        :return: ConsolePortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'device', 'name', 'cs_port', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_port_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_port_put`")
        # verify the required parameter 'device' is set
        if ('device' not in params) or (params['device'] is None):
            raise ValueError("Missing the required parameter `device` when calling `console_port_put`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `console_port_put`")
        # verify the required parameter 'cs_port' is set
        if ('cs_port' not in params) or (params['cs_port'] is None):
            raise ValueError("Missing the required parameter `cs_port` when calling `console_port_put`")

        resource_path = '/api/dcim/console-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'device' in params:
            form_params.append(('device', params['device']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'cs_port' in params:
            form_params.append(('cs_port', params['cs_port']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsolePortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def console_server_port_list_get(self, pk, **kwargs):
        """
        List console server ports (by device)
        <p>List console server ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_server_port_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsoleServerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.console_server_port_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.console_server_port_list_get_with_http_info(pk, **kwargs)
            return data

    def console_server_port_list_get_with_http_info(self, pk, **kwargs):
        """
        List console server ports (by device)
        <p>List console server ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.console_server_port_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ConsoleServerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method console_server_port_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `console_server_port_list_get`")

        resource_path = '/api/dcim/devices/{pk}/console-server-ports/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConsoleServerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_bay_list_get(self, pk, **kwargs):
        """
        List device bays (by device)
        <p>List device bays (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_bay_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceBayNestedSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_bay_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.device_bay_list_get_with_http_info(pk, **kwargs)
            return data

    def device_bay_list_get_with_http_info(self, pk, **kwargs):
        """
        List device bays (by device)
        <p>List device bays (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_bay_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceBayNestedSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_bay_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `device_bay_list_get`")

        resource_path = '/api/dcim/devices/{pk}/device-bays/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceBayNestedSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_detail_get(self, pk, **kwargs):
        """
        Retrieve a single device
        <p>Retrieve a single device</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.device_detail_get_with_http_info(pk, **kwargs)
            return data

    def device_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single device
        <p>Retrieve a single device</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `device_detail_get`")

        resource_path = '/api/dcim/devices/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_list_get(self, **kwargs):
        """
        List devices (filterable)
        <p>List devices (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search
        :param str name: Name
        :param str serial: Serial number
        :param str asset_tag: Asset tag
        :param str site_id: Site (ID)
        :param str site: Site name (slug)
        :param str rack_id: Rack (ID)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :param str device_type_id: Device type (ID)
        :param str manufacturer_id: Manufacturer (ID)
        :param str manufacturer: Manufacturer (slug)
        :param str model: Device model (slug)
        :param str platform_id: Platform (ID)
        :param str platform: Platform (slug)
        :param str status: Status
        :param str is_console_server: Is a console server
        :param str is_pdu: Is a PDU
        :param str is_network_device: Is a network device
        :param str rack_group_id: Rack group (ID)
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :return: DeviceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_list_get_with_http_info(**kwargs)
        else:
            (data) = self.device_list_get_with_http_info(**kwargs)
            return data

    def device_list_get_with_http_info(self, **kwargs):
        """
        List devices (filterable)
        <p>List devices (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search
        :param str name: Name
        :param str serial: Serial number
        :param str asset_tag: Asset tag
        :param str site_id: Site (ID)
        :param str site: Site name (slug)
        :param str rack_id: Rack (ID)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :param str device_type_id: Device type (ID)
        :param str manufacturer_id: Manufacturer (ID)
        :param str manufacturer: Manufacturer (slug)
        :param str model: Device model (slug)
        :param str platform_id: Platform (ID)
        :param str platform: Platform (slug)
        :param str status: Status
        :param str is_console_server: Is a console server
        :param str is_pdu: Is a PDU
        :param str is_network_device: Is a network device
        :param str rack_group_id: Rack group (ID)
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :return: DeviceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q', 'name', 'serial', 'asset_tag', 'site_id', 'site', 'rack_id', 'role_id', 'role', 'device_type_id', 'manufacturer_id', 'manufacturer', 'model', 'platform_id', 'platform', 'status', 'is_console_server', 'is_pdu', 'is_network_device', 'rack_group_id', 'tenant_id', 'tenant']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/devices/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'q' in params:
            query_params['q'] = params['q']
        if 'name' in params:
            query_params['name'] = params['name']
        if 'serial' in params:
            query_params['serial'] = params['serial']
        if 'asset_tag' in params:
            query_params['asset_tag'] = params['asset_tag']
        if 'site_id' in params:
            query_params['site_id'] = params['site_id']
        if 'site' in params:
            query_params['site'] = params['site']
        if 'rack_id' in params:
            query_params['rack_id'] = params['rack_id']
        if 'role_id' in params:
            query_params['role_id'] = params['role_id']
        if 'role' in params:
            query_params['role'] = params['role']
        if 'device_type_id' in params:
            query_params['device_type_id'] = params['device_type_id']
        if 'manufacturer_id' in params:
            query_params['manufacturer_id'] = params['manufacturer_id']
        if 'manufacturer' in params:
            query_params['manufacturer'] = params['manufacturer']
        if 'model' in params:
            query_params['model'] = params['model']
        if 'platform_id' in params:
            query_params['platform_id'] = params['platform_id']
        if 'platform' in params:
            query_params['platform'] = params['platform']
        if 'status' in params:
            query_params['status'] = params['status']
        if 'is_console_server' in params:
            query_params['is_console_server'] = params['is_console_server']
        if 'is_pdu' in params:
            query_params['is_pdu'] = params['is_pdu']
        if 'is_network_device' in params:
            query_params['is_network_device'] = params['is_network_device']
        if 'rack_group_id' in params:
            query_params['rack_group_id'] = params['rack_group_id']
        if 'tenant_id' in params:
            query_params['tenant_id'] = params['tenant_id']
        if 'tenant' in params:
            query_params['tenant'] = params['tenant']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_role_detail_get(self, pk, **kwargs):
        """
        Retrieve a single device role
        <p>Retrieve a single device role</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_role_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_role_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.device_role_detail_get_with_http_info(pk, **kwargs)
            return data

    def device_role_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single device role
        <p>Retrieve a single device role</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_role_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_role_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `device_role_detail_get`")

        resource_path = '/api/dcim/device-roles/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceRoleSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_role_list_get(self, **kwargs):
        """
        List all device roles
        <p>List all device roles</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_role_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: DeviceRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_role_list_get_with_http_info(**kwargs)
        else:
            (data) = self.device_role_list_get_with_http_info(**kwargs)
            return data

    def device_role_list_get_with_http_info(self, **kwargs):
        """
        List all device roles
        <p>List all device roles</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_role_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: DeviceRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_role_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/device-roles/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceRoleSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_type_detail_get(self, pk, **kwargs):
        """
        Retrieve a single device type
        <p>Retrieve a single device type</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_type_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceTypeDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_type_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.device_type_detail_get_with_http_info(pk, **kwargs)
            return data

    def device_type_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single device type
        <p>Retrieve a single device type</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_type_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: DeviceTypeDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_type_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `device_type_detail_get`")

        resource_path = '/api/dcim/device-types/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceTypeDetailSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def device_type_list_get(self, **kwargs):
        """
        List device types (filterable)
        <p>List device types (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_type_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str manufacturer_id: Manufacturer (ID)
        :param str manufacturer: Manufacturer (slug)
        :param str model: Model
        :param str part_number: Part number
        :param str u_height: Height (U)
        :param str is_console_server: Is a console server
        :param str is_pdu: Is a PDU
        :param str is_network_device: Is a network device
        :return: DeviceTypeSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.device_type_list_get_with_http_info(**kwargs)
        else:
            (data) = self.device_type_list_get_with_http_info(**kwargs)
            return data

    def device_type_list_get_with_http_info(self, **kwargs):
        """
        List device types (filterable)
        <p>List device types (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.device_type_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str manufacturer_id: Manufacturer (ID)
        :param str manufacturer: Manufacturer (slug)
        :param str model: Model
        :param str part_number: Part number
        :param str u_height: Height (U)
        :param str is_console_server: Is a console server
        :param str is_pdu: Is a PDU
        :param str is_network_device: Is a network device
        :return: DeviceTypeSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manufacturer_id', 'manufacturer', 'model', 'part_number', 'u_height', 'is_console_server', 'is_pdu', 'is_network_device']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_type_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/device-types/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'manufacturer_id' in params:
            query_params['manufacturer_id'] = params['manufacturer_id']
        if 'manufacturer' in params:
            query_params['manufacturer'] = params['manufacturer']
        if 'model' in params:
            query_params['model'] = params['model']
        if 'part_number' in params:
            query_params['part_number'] = params['part_number']
        if 'u_height' in params:
            query_params['u_height'] = params['u_height']
        if 'is_console_server' in params:
            query_params['is_console_server'] = params['is_console_server']
        if 'is_pdu' in params:
            query_params['is_pdu'] = params['is_pdu']
        if 'is_network_device' in params:
            query_params['is_network_device'] = params['is_network_device']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DeviceTypeSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def graph_list_get(self, pk, **kwargs):
        """
        Returns a list of relevant graphs
        <p>Returns a list of relevant graphs</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.graph_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: GraphSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.graph_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.graph_list_get_with_http_info(pk, **kwargs)
            return data

    def graph_list_get_with_http_info(self, pk, **kwargs):
        """
        Returns a list of relevant graphs
        <p>Returns a list of relevant graphs</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.graph_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: GraphSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method graph_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `graph_list_get`")

        resource_path = '/api/dcim/interfaces/{pk}/graphs/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='GraphSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def graph_list_get_0(self, pk, **kwargs):
        """
        Returns a list of relevant graphs
        <p>Returns a list of relevant graphs</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.graph_list_get_0(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: GraphSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.graph_list_get_0_with_http_info(pk, **kwargs)
        else:
            (data) = self.graph_list_get_0_with_http_info(pk, **kwargs)
            return data

    def graph_list_get_0_with_http_info(self, pk, **kwargs):
        """
        Returns a list of relevant graphs
        <p>Returns a list of relevant graphs</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.graph_list_get_0_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: GraphSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method graph_list_get_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `graph_list_get_0`")

        resource_path = '/api/dcim/sites/{pk}/graphs/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='GraphSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_connection_delete(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_delete(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_connection_delete_with_http_info(pk, **kwargs)
        else:
            (data) = self.interface_connection_delete_with_http_info(pk, **kwargs)
            return data

    def interface_connection_delete_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_delete_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_connection_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_connection_delete`")

        resource_path = '/api/dcim/interface-connections/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceConnectionSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_connection_get(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_connection_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.interface_connection_get_with_http_info(pk, **kwargs)
            return data

    def interface_connection_get_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_connection_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_connection_get`")

        resource_path = '/api/dcim/interface-connections/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceConnectionSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_connection_list_get(self, **kwargs):
        """
        Retrieve a list of all interface connections
        <p>Retrieve a list of all interface connections</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_connection_list_get_with_http_info(**kwargs)
        else:
            (data) = self.interface_connection_list_get_with_http_info(**kwargs)
            return data

    def interface_connection_list_get_with_http_info(self, **kwargs):
        """
        Retrieve a list of all interface connections
        <p>Retrieve a list of all interface connections</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_connection_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/interface-connections/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceConnectionSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_connection_patch(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_patch(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str interface_a: 
        :param str interface_b: 
        :param bool connection_status: 
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_connection_patch_with_http_info(pk, **kwargs)
        else:
            (data) = self.interface_connection_patch_with_http_info(pk, **kwargs)
            return data

    def interface_connection_patch_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_patch_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str interface_a: 
        :param str interface_b: 
        :param bool connection_status: 
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'interface_a', 'interface_b', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_connection_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_connection_patch`")

        resource_path = '/api/dcim/interface-connections/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'interface_a' in params:
            form_params.append(('interface_a', params['interface_a']))
        if 'interface_b' in params:
            form_params.append(('interface_b', params['interface_b']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceConnectionSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_connection_put(self, pk, interface_a, interface_b, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_put(pk, interface_a, interface_b, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str interface_a:  (required)
        :param str interface_b:  (required)
        :param bool connection_status: 
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_connection_put_with_http_info(pk, interface_a, interface_b, **kwargs)
        else:
            (data) = self.interface_connection_put_with_http_info(pk, interface_a, interface_b, **kwargs)
            return data

    def interface_connection_put_with_http_info(self, pk, interface_a, interface_b, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_connection_put_with_http_info(pk, interface_a, interface_b, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str interface_a:  (required)
        :param str interface_b:  (required)
        :param bool connection_status: 
        :return: InterfaceConnectionSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'interface_a', 'interface_b', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_connection_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_connection_put`")
        # verify the required parameter 'interface_a' is set
        if ('interface_a' not in params) or (params['interface_a'] is None):
            raise ValueError("Missing the required parameter `interface_a` when calling `interface_connection_put`")
        # verify the required parameter 'interface_b' is set
        if ('interface_b' not in params) or (params['interface_b'] is None):
            raise ValueError("Missing the required parameter `interface_b` when calling `interface_connection_put`")

        resource_path = '/api/dcim/interface-connections/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'interface_a' in params:
            form_params.append(('interface_a', params['interface_a']))
        if 'interface_b' in params:
            form_params.append(('interface_b', params['interface_b']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceConnectionSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_detail_get(self, pk, **kwargs):
        """
        Retrieve a single interface
        <p>Retrieve a single interface</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.interface_detail_get_with_http_info(pk, **kwargs)
            return data

    def interface_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single interface
        <p>Retrieve a single interface</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: InterfaceDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_detail_get`")

        resource_path = '/api/dcim/interfaces/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceDetailSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def interface_list_get(self, pk, **kwargs):
        """
        List interfaces (by device)
        <p>List interfaces (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device_id: Device (ID)
        :param str device: Device (name)
        :param str name: Name
        :return: InterfaceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.interface_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.interface_list_get_with_http_info(pk, **kwargs)
            return data

    def interface_list_get_with_http_info(self, pk, **kwargs):
        """
        List interfaces (by device)
        <p>List interfaces (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.interface_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device_id: Device (ID)
        :param str device: Device (name)
        :param str name: Name
        :return: InterfaceSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'device_id', 'device', 'name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method interface_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `interface_list_get`")

        resource_path = '/api/dcim/devices/{pk}/interfaces/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}
        if 'device_id' in params:
            query_params['device_id'] = params['device_id']
        if 'device' in params:
            query_params['device'] = params['device']
        if 'name' in params:
            query_params['name'] = params['name']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InterfaceSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def lldp_neighbors_get(self, pk, **kwargs):
        """
        Retrieve live LLDP neighbors of a device
        <p>Retrieve live LLDP neighbors of a device</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.lldp_neighbors_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.lldp_neighbors_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.lldp_neighbors_get_with_http_info(pk, **kwargs)
            return data

    def lldp_neighbors_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve live LLDP neighbors of a device
        <p>Retrieve live LLDP neighbors of a device</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.lldp_neighbors_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lldp_neighbors_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `lldp_neighbors_get`")

        resource_path = '/api/dcim/devices/{pk}/lldp-neighbors/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='object',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def manufacturer_detail_get(self, pk, **kwargs):
        """
        Retrieve a single hardware manufacturers
        <p>Retrieve a single hardware manufacturers</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.manufacturer_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ManufacturerSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.manufacturer_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.manufacturer_detail_get_with_http_info(pk, **kwargs)
            return data

    def manufacturer_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single hardware manufacturers
        <p>Retrieve a single hardware manufacturers</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.manufacturer_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ManufacturerSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manufacturer_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `manufacturer_detail_get`")

        resource_path = '/api/dcim/manufacturers/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ManufacturerSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def manufacturer_list_get(self, **kwargs):
        """
        List all hardware manufacturers
        <p>List all hardware manufacturers</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.manufacturer_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ManufacturerSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.manufacturer_list_get_with_http_info(**kwargs)
        else:
            (data) = self.manufacturer_list_get_with_http_info(**kwargs)
            return data

    def manufacturer_list_get_with_http_info(self, **kwargs):
        """
        List all hardware manufacturers
        <p>List all hardware manufacturers</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.manufacturer_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ManufacturerSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manufacturer_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/manufacturers/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ManufacturerSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def module_list_get(self, pk, **kwargs):
        """
        List device modules (by device)
        <p>List device modules (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.module_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ModuleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.module_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.module_list_get_with_http_info(pk, **kwargs)
            return data

    def module_list_get_with_http_info(self, pk, **kwargs):
        """
        List device modules (by device)
        <p>List device modules (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.module_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: ModuleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method module_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `module_list_get`")

        resource_path = '/api/dcim/devices/{pk}/modules/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ModuleSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def platform_detail_get(self, pk, **kwargs):
        """
        Retrieve a single platform
        <p>Retrieve a single platform</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platform_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PlatformSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platform_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.platform_detail_get_with_http_info(pk, **kwargs)
            return data

    def platform_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single platform
        <p>Retrieve a single platform</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platform_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PlatformSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platform_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `platform_detail_get`")

        resource_path = '/api/dcim/platforms/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PlatformSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def platform_list_get(self, **kwargs):
        """
        List all platforms
        <p>List all platforms</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platform_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: PlatformSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.platform_list_get_with_http_info(**kwargs)
        else:
            (data) = self.platform_list_get_with_http_info(**kwargs)
            return data

    def platform_list_get_with_http_info(self, **kwargs):
        """
        List all platforms
        <p>List all platforms</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.platform_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: PlatformSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method platform_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/platforms/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PlatformSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_outlet_list_get(self, pk, **kwargs):
        """
        List power outlets (by device)
        <p>List power outlets (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_outlet_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerOutletSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_outlet_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.power_outlet_list_get_with_http_info(pk, **kwargs)
            return data

    def power_outlet_list_get_with_http_info(self, pk, **kwargs):
        """
        List power outlets (by device)
        <p>List power outlets (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_outlet_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerOutletSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_outlet_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_outlet_list_get`")

        resource_path = '/api/dcim/devices/{pk}/power-outlets/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerOutletSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_port_delete(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_delete(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_port_delete_with_http_info(pk, **kwargs)
        else:
            (data) = self.power_port_delete_with_http_info(pk, **kwargs)
            return data

    def power_port_delete_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_delete_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_port_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_port_delete`")

        resource_path = '/api/dcim/power-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_port_get(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_port_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.power_port_get_with_http_info(pk, **kwargs)
            return data

    def power_port_get_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_port_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_port_get`")

        resource_path = '/api/dcim/power-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_port_list_get(self, pk, **kwargs):
        """
        List power ports (by device)
        <p>List power ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_port_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.power_port_list_get_with_http_info(pk, **kwargs)
            return data

    def power_port_list_get_with_http_info(self, pk, **kwargs):
        """
        List power ports (by device)
        <p>List power ports (by device)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_port_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_port_list_get`")

        resource_path = '/api/dcim/devices/{pk}/power-ports/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_port_patch(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_patch(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device: 
        :param str name: 
        :param str power_outlet: 
        :param bool connection_status: 
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_port_patch_with_http_info(pk, **kwargs)
        else:
            (data) = self.power_port_patch_with_http_info(pk, **kwargs)
            return data

    def power_port_patch_with_http_info(self, pk, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_patch_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device: 
        :param str name: 
        :param str power_outlet: 
        :param bool connection_status: 
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'device', 'name', 'power_outlet', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_port_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_port_patch`")

        resource_path = '/api/dcim/power-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'device' in params:
            form_params.append(('device', params['device']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'power_outlet' in params:
            form_params.append(('power_outlet', params['power_outlet']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def power_port_put(self, pk, device, name, power_outlet, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_put(pk, device, name, power_outlet, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device:  (required)
        :param str name:  (required)
        :param str power_outlet:  (required)
        :param bool connection_status: 
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.power_port_put_with_http_info(pk, device, name, power_outlet, **kwargs)
        else:
            (data) = self.power_port_put_with_http_info(pk, device, name, power_outlet, **kwargs)
            return data

    def power_port_put_with_http_info(self, pk, device, name, power_outlet, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.power_port_put_with_http_info(pk, device, name, power_outlet, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :param str device:  (required)
        :param str name:  (required)
        :param str power_outlet:  (required)
        :param bool connection_status: 
        :return: PowerPortSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk', 'device', 'name', 'power_outlet', 'connection_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method power_port_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `power_port_put`")
        # verify the required parameter 'device' is set
        if ('device' not in params) or (params['device'] is None):
            raise ValueError("Missing the required parameter `device` when calling `power_port_put`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `power_port_put`")
        # verify the required parameter 'power_outlet' is set
        if ('power_outlet' not in params) or (params['power_outlet'] is None):
            raise ValueError("Missing the required parameter `power_outlet` when calling `power_port_put`")

        resource_path = '/api/dcim/power-ports/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'device' in params:
            form_params.append(('device', params['device']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'power_outlet' in params:
            form_params.append(('power_outlet', params['power_outlet']))
        if 'connection_status' in params:
            form_params.append(('connection_status', params['connection_status']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PowerPortSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_detail_get(self, pk, **kwargs):
        """
        Retrieve a single rack
        <p>Retrieve a single rack</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.rack_detail_get_with_http_info(pk, **kwargs)
            return data

    def rack_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single rack
        <p>Retrieve a single rack</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackDetailSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `rack_detail_get`")

        resource_path = '/api/dcim/racks/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackDetailSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_group_detail_get(self, pk, **kwargs):
        """
        Retrieve a single rack group
        <p>Retrieve a single rack group</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_group_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackGroupSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_group_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.rack_group_detail_get_with_http_info(pk, **kwargs)
            return data

    def rack_group_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single rack group
        <p>Retrieve a single rack group</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_group_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackGroupSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_group_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `rack_group_detail_get`")

        resource_path = '/api/dcim/rack-groups/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackGroupSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_group_list_get(self, **kwargs):
        """
        List all rack groups
        <p>List all rack groups</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_group_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str site_id: Site (ID)
        :param str site: Site (slug)
        :return: RackGroupSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_group_list_get_with_http_info(**kwargs)
        else:
            (data) = self.rack_group_list_get_with_http_info(**kwargs)
            return data

    def rack_group_list_get_with_http_info(self, **kwargs):
        """
        List all rack groups
        <p>List all rack groups</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_group_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str site_id: Site (ID)
        :param str site: Site (slug)
        :return: RackGroupSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'site']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_group_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/rack-groups/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'site_id' in params:
            query_params['site_id'] = params['site_id']
        if 'site' in params:
            query_params['site'] = params['site']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackGroupSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_list_get(self, **kwargs):
        """
        List racks (filterable)
        <p>List racks (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search
        :param str site_id: Site (ID)
        :param str site: Site (slug)
        :param str u_height: Height (U)
        :param str group_id: Group (ID)
        :param str group: Group
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :return: RackSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_list_get_with_http_info(**kwargs)
        else:
            (data) = self.rack_list_get_with_http_info(**kwargs)
            return data

    def rack_list_get_with_http_info(self, **kwargs):
        """
        List racks (filterable)
        <p>List racks (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search
        :param str site_id: Site (ID)
        :param str site: Site (slug)
        :param str u_height: Height (U)
        :param str group_id: Group (ID)
        :param str group: Group
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :return: RackSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q', 'site_id', 'site', 'u_height', 'group_id', 'group', 'tenant_id', 'tenant', 'role_id', 'role']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/racks/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'q' in params:
            query_params['q'] = params['q']
        if 'site_id' in params:
            query_params['site_id'] = params['site_id']
        if 'site' in params:
            query_params['site'] = params['site']
        if 'u_height' in params:
            query_params['u_height'] = params['u_height']
        if 'group_id' in params:
            query_params['group_id'] = params['group_id']
        if 'group' in params:
            query_params['group'] = params['group']
        if 'tenant_id' in params:
            query_params['tenant_id'] = params['tenant_id']
        if 'tenant' in params:
            query_params['tenant'] = params['tenant']
        if 'role_id' in params:
            query_params['role_id'] = params['role_id']
        if 'role' in params:
            query_params['role'] = params['role']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_list_get_0(self, site, **kwargs):
        """
        List racks (filterable)
        <p>List racks (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_list_get_0(site, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str site:  (required)
        :param str q: Search
        :param str site_id: Site (ID)
        :param str site2: Site (slug)
        :param str u_height: Height (U)
        :param str group_id: Group (ID)
        :param str group: Group
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :return: RackSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_list_get_0_with_http_info(site, **kwargs)
        else:
            (data) = self.rack_list_get_0_with_http_info(site, **kwargs)
            return data

    def rack_list_get_0_with_http_info(self, site, **kwargs):
        """
        List racks (filterable)
        <p>List racks (filterable)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_list_get_0_with_http_info(site, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str site:  (required)
        :param str q: Search
        :param str site_id: Site (ID)
        :param str site2: Site (slug)
        :param str u_height: Height (U)
        :param str group_id: Group (ID)
        :param str group: Group
        :param str tenant_id: Tenant (ID)
        :param str tenant: Tenant (slug)
        :param str role_id: Role (ID)
        :param str role: Role (slug)
        :return: RackSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site', 'q', 'site_id', 'site2', 'u_height', 'group_id', 'group', 'tenant_id', 'tenant', 'role_id', 'role']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_list_get_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site' is set
        if ('site' not in params) or (params['site'] is None):
            raise ValueError("Missing the required parameter `site` when calling `rack_list_get_0`")

        resource_path = '/api/dcim/sites/{site}/racks/'.replace('{format}', 'json')
        path_params = {}
        if 'site' in params:
            path_params['site'] = params['site']

        query_params = {}
        if 'q' in params:
            query_params['q'] = params['q']
        if 'site_id' in params:
            query_params['site_id'] = params['site_id']
        if 'site2' in params:
            query_params['site'] = params['site2']
        if 'u_height' in params:
            query_params['u_height'] = params['u_height']
        if 'group_id' in params:
            query_params['group_id'] = params['group_id']
        if 'group' in params:
            query_params['group'] = params['group']
        if 'tenant_id' in params:
            query_params['tenant_id'] = params['tenant_id']
        if 'tenant' in params:
            query_params['tenant'] = params['tenant']
        if 'role_id' in params:
            query_params['role_id'] = params['role_id']
        if 'role' in params:
            query_params['role'] = params['role']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_role_detail_get(self, pk, **kwargs):
        """
        Retrieve a single rack role
        <p>Retrieve a single rack role</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_role_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_role_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.rack_role_detail_get_with_http_info(pk, **kwargs)
            return data

    def rack_role_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single rack role
        <p>Retrieve a single rack role</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_role_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: RackRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_role_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `rack_role_detail_get`")

        resource_path = '/api/dcim/rack-roles/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackRoleSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_role_list_get(self, **kwargs):
        """
        List all rack roles
        <p>List all rack roles</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_role_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: RackRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_role_list_get_with_http_info(**kwargs)
        else:
            (data) = self.rack_role_list_get_with_http_info(**kwargs)
            return data

    def rack_role_list_get_with_http_info(self, **kwargs):
        """
        List all rack roles
        <p>List all rack roles</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_role_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: RackRoleSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_role_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/rack-roles/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RackRoleSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rack_unit_list_get(self, pk, **kwargs):
        """
        List rack units (by rack)
        <p>List rack units (by rack)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_unit_list_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rack_unit_list_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.rack_unit_list_get_with_http_info(pk, **kwargs)
            return data

    def rack_unit_list_get_with_http_info(self, pk, **kwargs):
        """
        List rack units (by rack)
        <p>List rack units (by rack)</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rack_unit_list_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rack_unit_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `rack_unit_list_get`")

        resource_path = '/api/dcim/racks/{pk}/rack-units/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='object',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def related_connections_get(self, **kwargs):
        """
        Retrieve all connections related to a given console/power/interface connection
        <p>Retrieve all connections related to a given console/power/interface connection</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.related_connections_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.related_connections_get_with_http_info(**kwargs)
        else:
            (data) = self.related_connections_get_with_http_info(**kwargs)
            return data

    def related_connections_get_with_http_info(self, **kwargs):
        """
        Retrieve all connections related to a given console/power/interface connection
        <p>Retrieve all connections related to a given console/power/interface connection</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.related_connections_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method related_connections_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/related-connections/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='object',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def site_detail_get(self, pk, **kwargs):
        """
        Retrieve a single site
        <p>Retrieve a single site</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.site_detail_get(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: SiteSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.site_detail_get_with_http_info(pk, **kwargs)
        else:
            (data) = self.site_detail_get_with_http_info(pk, **kwargs)
            return data

    def site_detail_get_with_http_info(self, pk, **kwargs):
        """
        Retrieve a single site
        <p>Retrieve a single site</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.site_detail_get_with_http_info(pk, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str pk:  (required)
        :return: SiteSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pk']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method site_detail_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pk' is set
        if ('pk' not in params) or (params['pk'] is None):
            raise ValueError("Missing the required parameter `pk` when calling `site_detail_get`")

        resource_path = '/api/dcim/sites/{pk}/'.replace('{format}', 'json')
        path_params = {}
        if 'pk' in params:
            path_params['pk'] = params['pk']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SiteSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def site_list_get(self, **kwargs):
        """
        List all sites
        <p>List all sites</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.site_list_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: SiteSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.site_list_get_with_http_info(**kwargs)
        else:
            (data) = self.site_list_get_with_http_info(**kwargs)
            return data

    def site_list_get_with_http_info(self, **kwargs):
        """
        List all sites
        <p>List all sites</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.site_list_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: SiteSerializer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method site_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/dcim/sites/'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SiteSerializer',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def topology_map_get(self, slug, **kwargs):
        """
        Generate a topology diagram
        <p>Generate a topology diagram</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.topology_map_get(slug, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str slug:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.topology_map_get_with_http_info(slug, **kwargs)
        else:
            (data) = self.topology_map_get_with_http_info(slug, **kwargs)
            return data

    def topology_map_get_with_http_info(self, slug, **kwargs):
        """
        Generate a topology diagram
        <p>Generate a topology diagram</p>

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.topology_map_get_with_http_info(slug, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str slug:  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['slug']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method topology_map_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'slug' is set
        if ('slug' not in params) or (params['slug'] is None):
            raise ValueError("Missing the required parameter `slug` when calling `topology_map_get`")

        resource_path = '/api/dcim/topology-maps/{slug}/'.replace('{format}', 'json')
        path_params = {}
        if 'slug' in params:
            path_params['slug'] = params['slug']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='object',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
